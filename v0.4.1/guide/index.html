<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · COSMO.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-134239283-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://oxfordcontrol.github.io/COSMO.jl/stable/guide/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><script src="../assets/github_buttons.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="COSMO.jl logo"/></a><h1>COSMO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li class="current"><a class="toctext" href>User Guide</a><ul class="internal"><li><a class="toctext" href="#Model-1">Model</a></li><li><a class="toctext" href="#Objective-Function-1">Objective Function</a></li><li><a class="toctext" href="#Constraints-1">Constraints</a></li><li><a class="toctext" href="#Settings-1">Settings</a></li><li><a class="toctext" href="#Assembling-the-model-1">Assembling the model</a></li><li><a class="toctext" href="#Warm-starting-1">Warm starting</a></li><li><a class="toctext" href="#Solving-1">Solving</a></li><li><a class="toctext" href="#Results-1">Results</a></li></ul></li><li><a class="toctext" href="../jump/">JuMP Interface</a></li><li><a class="toctext" href="../method/">Method</a></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../citing/">Citing COSMO</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>User Guide</a></li></ul><a class="edit-page" href="https://github.com/oxfordcontrol/COSMO.jl/blob/master/docs/src/guide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><p>This user guide describes the basic structures and functions to define an optimisation problem, to solve the problem and to analyse the result. If you want to use <code>JuMP</code> to describe the problem, see the <a href="../jump/#JuMP-Interface-1">JuMP Interface</a> section.</p><p>COSMO solves optimisation problems in the following format:</p><div>\[\begin{array}{ll} \mbox{minimize} &amp; \textstyle{\frac{1}{2}}x^\top Px + q^\top x\\ \mbox{subject to} &amp; Ax + s = b \\ &amp; s \in \mathcal{K}, \end{array}\]</div><p>with decision variables <span>$x \in \mathbb{R}^n$</span>, <span>$s \in \mathbb{R}^m$</span> and data matrices <span>$P=P^\top \succeq 0$</span>, <span>$q \in \mathbb{R}^n$</span>, <span>$A \in \mathbb{R}^{m \times n}$</span>, and <span>$b \in \mathbb{R}^m$</span>. The convex set <span>$\mathcal{K}$</span>  is a composition of convex sets and cones.</p><h2><a class="nav-anchor" id="Model-1" href="#Model-1">Model</a></h2><p>The problem data, user settings and workspace variables are all stored in a <code>Model</code>. To get started define an empty model:</p><pre><code class="language-julia">model = COSMO.Model()</code></pre><p>To initialize the model with an optimisation problem we need to define three more things:</p><ul><li>the objective function, i.e. the matrix <code>P</code> and the vector <code>q</code> in <span>$\frac{1}{2}x^\top P x + q^\top x$</span></li><li>an array of constraints</li><li>a <code>Settings</code> object that specifies how COSMO solves the problem <em>(optional)</em></li></ul><h2><a class="nav-anchor" id="Objective-Function-1" href="#Objective-Function-1">Objective Function</a></h2><p>To set the objective function of your optimisation problem simply define the square positive semidefinite matrix <span>$P \in \mathrm{R}^{n\times n}$</span> and the vector <span>$q \in \mathrm{R}^{n}$</span>. You might have to transform your optimisation problem into a solver compatible format for this step.</p><h2><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h2><p>The COSMO interface expects constraints to have the form <span>$A_i x + b_i \in \mathcal{K}_i$</span>, where <span>$\mathcal{K}_i$</span> is one of the convex sets defined below:</p><table><tr><th style="text-align: right">Convex Set</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">ZeroSet</td><td style="text-align: right">The set <span>$\{ 0 \}^{dim}$</span> that contains the origin</td></tr><tr><td style="text-align: right">Nonnegatives</td><td style="text-align: right">The nonnegative orthant <span>$\{ x \in \mathbb{R}^{dim} : x_i \ge 0, \forall i=1,\dots,\mathrm{dim} \}$</span></td></tr><tr><td style="text-align: right">Box(u, l)</td><td style="text-align: right">The hyperbox <span>$\{ x \in \mathbb{R}^{dim} : l \leq x \leq u\}$</span> with vectors <span>$l \in \mathbb{R}^{dim} \cup \{-\infty\}$</span> and <span>$u \in \mathbb{R}^{dim} \cup \{+\infty\}$</span></td></tr><tr><td style="text-align: right">SecondOrderCone</td><td style="text-align: right">The second-order (Lorenz) cone <span>$\{ (t,x) \in \mathbb{R}^{dim}  :  |x|_2   \leq t \}$</span></td></tr><tr><td style="text-align: right">PsdCone</td><td style="text-align: right">The vectorized positive semidefinite cone <span>$\mathcal{S}_+^{dim}$</span>. <span>$x$</span> is the vector obtained by stacking the columns of the positive semidefinite matrix <span>$X$</span>, i.e. <span>$X \in \mathbb{S}^{\sqrt{dim}}_+ \Rightarrow \text{vec}(X) = x \in \mathcal{S}_+^{dim}$</span></td></tr><tr><td style="text-align: right">PsdConeTriangle</td><td style="text-align: right">The vectorized positive semidefinite cone <span>$\mathcal{S}_+^{dim}$</span>. <span>$x$</span> is the vector obtained by stacking the columns of the upper triangular part of the positive semidefinite matrix <span>$X$</span>, i.e. <span>$X \in \mathbb{S}^{d}_+ \Rightarrow \text{svec}(X) = x \in \mathcal{S}_+^{dim}$</span> where <span>$d=\sqrt{1/4 + 2 \text{dim}} - 1/2$</span></td></tr></table><p>The constructor for a constraint expects a matrix <code>A</code>, a vector <code>b</code> and a <code>convex_set</code>.</p><p>Lets consider a problem with a decision variable <span>$x \in \mathbb{R}^5$</span>. Suppose we want to create the two constraint <span>$x_2 + 5 \geq 0$</span> and <span>$x_3 - 3 \geq 0$</span>. We can do this either by creating two constraints and adding them to an array:</p><pre><code class="language-julia">  constraint1 = COSMO.Constraint([0.0 1.0 0.0 0.0 0.0], 5.0, COSMO.Nonnegatives)
  constraint2 = COSMO.Constraint([0.0 0.0 1.0 0.0 0.0], -3.0, COSMO.Nonnegatives)
  constraints = [constraint1; constraint2]</code></pre><p>The second option is to include both in one constraint:</p><pre><code class="language-julia">constraint1 = COSMO.Constraint([0.0 1.0 0.0 0.0 0.0; 0.0 0.0 1.0 0.0 0.0], [5.0; -3.0], COSMO.Nonnegatives)</code></pre><p>Another way to construct the constraint is to used the optional arguments <code>dim</code>, the dimension of <code>x</code>, and <code>indices</code>, the elements of <code>x</code> that appear in the constraint. When specifying these arguments, <code>A</code> and <code>b</code> only refer to the elements of <code>x</code> in <code>indices</code>:</p><pre><code class="language-julia">constraint1 = COSMO.Constraint([1.0 0.0; 0.0 1.0], [5.0; -3.0], COSMO.Nonnegatives, 5, 2:3)</code></pre><p>Consider as a second example the positive semidefinite constraint on a matrix <span>$X \in  \mathbb{S}_+^{3}$</span>. Our decision variable is the vector <span>$x$</span> obtained by stacking the columns of <span>$X$</span>. We can specify the constraint on <span>$x$</span> in the following way:</p><div>\[I_9 x + \{0\}_9 \in \mathcal{S}_+^9,\]</div><p>or in Julia:</p><pre><code class="language-julia">constraint1 = COSMO.Constraint(Matrix(1.0I, 9, 9), zeros(9), COSMO.PsdCone)</code></pre><p>Several constraints can be combined in an array:</p><pre><code class="language-julia">constraints = [constraint_1, constraint_2, ..., constraint_N]</code></pre><h2><a class="nav-anchor" id="Settings-1" href="#Settings-1">Settings</a></h2><p>The solver settings are stored in a <code>Settings</code> object and can be adjusted by the user. To create a <code>Settings</code> object just call the constructor:</p><pre><code class="language-julia">settings = COSMO.Settings()</code></pre><p>The settings object holds the following options and default values:</p><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Values (default)</th></tr><tr><td style="text-align: right">rho</td><td style="text-align: right">ADMM rho step</td><td style="text-align: right">0.1</td></tr><tr><td style="text-align: right">sigma</td><td style="text-align: right">ADMM sigma step</td><td style="text-align: right">1e-6</td></tr><tr><td style="text-align: right">alpha</td><td style="text-align: right">Relaxation parameter</td><td style="text-align: right">1.6</td></tr><tr><td style="text-align: right">eps_abs</td><td style="text-align: right">Absolute residual tolerance</td><td style="text-align: right">1e-4</td></tr><tr><td style="text-align: right">eps_rel</td><td style="text-align: right">Relative residual tolerance</td><td style="text-align: right">1e-4</td></tr><tr><td style="text-align: right">eps_prim_inf</td><td style="text-align: right">Primal infeasibility tolerance</td><td style="text-align: right">1e-4</td></tr><tr><td style="text-align: right">eps_dual_inf</td><td style="text-align: right">Dual infeasibility tolerance</td><td style="text-align: right">1e-4</td></tr><tr><td style="text-align: right">max_iter</td><td style="text-align: right">Maximum number of iterations</td><td style="text-align: right">2500</td></tr><tr><td style="text-align: right">verbose</td><td style="text-align: right">Verbose printing</td><td style="text-align: right">false</td></tr><tr><td style="text-align: right">verbose_timing</td><td style="text-align: right">Verbose timing</td><td style="text-align: right">false</td></tr><tr><td style="text-align: right">check_termination</td><td style="text-align: right">Check termination interval</td><td style="text-align: right">40</td></tr><tr><td style="text-align: right">check_infeasibility</td><td style="text-align: right">Check infeasibility interval</td><td style="text-align: right">40</td></tr><tr><td style="text-align: right">scaling</td><td style="text-align: right">Number of scaling iterations</td><td style="text-align: right">10</td></tr><tr><td style="text-align: right">adaptive_rho</td><td style="text-align: right">Automatic adaptation of step size parameter</td><td style="text-align: right">true</td></tr><tr><td style="text-align: right">time_limit</td><td style="text-align: right">set solver time limit in s</td><td style="text-align: right">0.0</td></tr></table><p>To adjust those values, either pass your preferred option and parameter as a key-value pair to the constructor or edit the corresponding field afterwards. For example if you want to enable verbose printing and increase the solver accuracy, you can type</p><pre><code class="language-julia">settings = COSMO.Settings(verbose = true, eps_abs = 1e-5, eps_rel = 1e-5)
# the following is equivalent
settings = COSMO.Settings()
settings.verbose = true
settings.eps_abs = 1e-5
settings.eps_rel = 1e-5</code></pre><h2><a class="nav-anchor" id="Assembling-the-model-1" href="#Assembling-the-model-1">Assembling the model</a></h2><p>Once the objective function and an array of constraints have been defined, we can assemble the model with</p><pre><code class="language-julia">COSMO.assemble!(model, P, q, constraints)</code></pre><p>This simply sets the corresponding variables in the model and transforms the array of constraints into the problem format defined at the top of the page.</p><p>If you want to change the default settings, you can pass your settings object <code>custom_settings</code> to the <code>assemble!</code> function:</p><pre><code class="language-julia">COSMO.assemble!(model, P, q, constraints, settings = custom_settings)</code></pre><h2><a class="nav-anchor" id="Warm-starting-1" href="#Warm-starting-1">Warm starting</a></h2><p>One of the advantages of ADMM-based solvers is that they can be easily warm started. By providing starting values for the primal variable <code>x</code> and/or the dual variable <code>y</code> in the vicinity of their optimal values, the number of iterations to convergence can often be dramatically decreased.</p><p>Consider the case where you have a decision variable <span>$x \in \mathbb{R}^3$</span> and a dual variable <span>$y \in \mathbb{R}^2$</span>. Assume you expect their optimal values to be close to <span>$x_0 = (1, 5, 3)$</span> and <span>$y_0 = (1, 2)$</span>. You can pass these values when assembling the model.</p><pre><code class="language-julia">x_0 = [1.0; 5.0; 3.0]
y_0 = [1.0; 2.0]
COSMO.assemble!(model, P, q, constraints, x0 = x_0, y0 = y_0)</code></pre><p>Another option is to use</p><pre><code class="language-julia">COSMO.assemble!(model, P, q, constraints)
warm_start_primal!(model, x_0)
warm_start_dual!(model, y_0)</code></pre><h2><a class="nav-anchor" id="Solving-1" href="#Solving-1">Solving</a></h2><p>After the model has been assembled, we can solve the problem by typing</p><pre><code class="language-julia">results = COSMO.optimize!(model)</code></pre><p>Once the solver algorithm terminates, it will return a <code>Results</code> object that gives information about the status of the solver. If successful, it contains the optimal objective value and optimal primal and dual variables. For more information see the following section.</p><h2><a class="nav-anchor" id="Results-1" href="#Results-1">Results</a></h2><p>After attempting to solve the problem, COSMO will return a result object with the following fields:</p><table><tr><th style="text-align: right">Fieldname</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">x</td><td style="text-align: right">Vector{Float64}</td><td style="text-align: right">Primal variable</td></tr><tr><td style="text-align: right">y</td><td style="text-align: right">Vector{Float64}</td><td style="text-align: right">Dual variable</td></tr><tr><td style="text-align: right">s</td><td style="text-align: right">Vector{Float64}</td><td style="text-align: right">(Primal) set variable</td></tr><tr><td style="text-align: right">obj_val</td><td style="text-align: right">Float64</td><td style="text-align: right">Objective value</td></tr><tr><td style="text-align: right">iter</td><td style="text-align: right">Int64</td><td style="text-align: right">Number of iterations</td></tr><tr><td style="text-align: right">status</td><td style="text-align: right">Symbol</td><td style="text-align: right">Solution status</td></tr><tr><td style="text-align: right">info</td><td style="text-align: right">COSMO.ResultInfo</td><td style="text-align: right">Struct with more information</td></tr><tr><td style="text-align: right">times</td><td style="text-align: right">COSMO.ResultTimes</td><td style="text-align: right">Struct with several measured times</td></tr></table><h3><a class="nav-anchor" id="Status-Codes-1" href="#Status-Codes-1">Status Codes</a></h3><p>COSMO will return one of the following statuses:</p><table><tr><th style="text-align: right">Status Code</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">:Solved</td><td style="text-align: right">An optimal solution was found</td></tr><tr><td style="text-align: right">:Unsolved</td><td style="text-align: right">Default value</td></tr><tr><td style="text-align: right">:Max_iter_reached</td><td style="text-align: right">Solver reached iteration limit (set with <code>Settings.max_iter</code>)</td></tr><tr><td style="text-align: right">:Time_limit_reached</td><td style="text-align: right">Solver reached time limit (set with <code>Settings.time_limit</code>)</td></tr><tr><td style="text-align: right">:Primal_infeasible</td><td style="text-align: right">Problem is primal infeasible</td></tr><tr><td style="text-align: right">:Dual_infeasible</td><td style="text-align: right">Problem is dual infeasible</td></tr></table><h3><a class="nav-anchor" id="Timings-1" href="#Timings-1">Timings</a></h3><p>If <code>settings.verbose_timing</code> is set to <code>true</code>, COSMO will report the following times in <code>result.times</code>:</p><table><tr><th style="text-align: right">Time Name</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right">solver_time</td><td style="text-align: right">Total time used to solve the problem</td></tr><tr><td style="text-align: right">setup_time</td><td style="text-align: right">Setup time = graph_time + factor_time</td></tr><tr><td style="text-align: right">graph_time</td><td style="text-align: right">Time used to perform chordal decomposition</td></tr><tr><td style="text-align: right">factor_time</td><td style="text-align: right">Time used to factor the system of linear equations</td></tr><tr><td style="text-align: right">iter_time</td><td style="text-align: right">Time spent in iteration loop</td></tr><tr><td style="text-align: right">proj_time</td><td style="text-align: right">Time spent in projection functions</td></tr><tr><td style="text-align: right">post_time</td><td style="text-align: right">Time used for post processing</td></tr></table><p>It holds: <code>solver_time</code> = <code>setup_time</code>+ <code>iter_time</code> + <code>post_time</code>,</p><p><code>setup_time</code> = <code>graph_time</code>+ <code>factor_time</code>,</p><p><code>proj_time</code> is a subset of <code>iter_time</code>.</p><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../jump/"><span class="direction">Next</span><span class="title">JuMP Interface</span></a></footer></article></body></html>
