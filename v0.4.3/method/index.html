<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Method · COSMO.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-134239283-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://oxfordcontrol.github.io/COSMO.jl/stable/method/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><script src="../assets/github_buttons.js"></script></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="COSMO.jl logo"/></a><h1>COSMO.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><span class="toctext">User Guide</span><ul><li><a class="toctext" href="../getting_started/">Getting Started</a></li><li><a class="toctext" href="../jump/">JuMP Interface</a></li><li><a class="toctext" href="../lin_solver/">Linear System Solver</a></li><li><a class="toctext" href="../decomposition/">Chordal Decomposition</a></li></ul></li><li class="current"><a class="toctext" href>Method</a><ul class="internal"><li><a class="toctext" href="#Dual-problem-1">Dual problem</a></li><li><a class="toctext" href="#Algorithm-1">Algorithm</a></li><li><a class="toctext" href="#Scaling-1">Scaling</a></li><li><a class="toctext" href="#Termination-criteria-1">Termination criteria</a></li><li><a class="toctext" href="#Infeasibility-detection-1">Infeasibility detection</a></li></ul></li><li><a class="toctext" href="../examples/">Examples</a></li><li><a class="toctext" href="../citing/">Citing COSMO</a></li><li><a class="toctext" href="../contributing/">Contributing</a></li><li><a class="toctext" href="../api/">API Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Method</a></li></ul><a class="edit-page" href="https://github.com/oxfordcontrol/COSMO.jl/blob/master/docs/src/method.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Method</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Method-1" href="#Method-1">Method</a></h1><p>This section describes COSMO&#39;s underlying ADMM algorithm and how the user can use the settings to adjust this algorithm. For a more detailed explanation take a look at the associated publication in <a href="../citing/#Citing-COSMO-1">Citing COSMO</a>.</p><p>COSMO solves problems with quadratic objective function and a number of conic constraints in the following form:</p><div>\[\begin{array}{ll} \mbox{minimize} &amp; \textstyle{\frac{1}{2}}x^\top Px + q^\top x\\ \mbox{subject to} &amp; Ax + s = b \\ &amp; s \in \mathcal{K}, \end{array}\]</div><p>with primal decision variable <span>$x \in \mathbb{R}^n$</span>, primal slack variable <span>$s \in \mathbb{R}^m$</span>. The objective function is defined by positive semidefinite matrix <span>$P=P^\top \succeq 0$</span> and vector <span>$q \in \mathbb{R}^n$</span>. The constraints are defined by matrix <span>$A \in \mathbb{R}^{m \times n}$</span>, vector <span>$b \in \mathbb{R}^m$</span> and a non-empty, closed convex set <span>$\mathcal{K}$</span>. The convex set itself can be a Cartesian product of convex sets in the form:</p><div>\[  \mathcal{K} = \mathcal{K}_1^{m_1} \times \mathcal{K}_2^{m_2} \times \cdots \times \mathcal{K}_N^{m_N}.\]</div><p>Accordingly, by an appropriate choice of convex sets one can represent any LP, QP, SOCP or SDP.</p><h2><a class="nav-anchor" id="Dual-problem-1" href="#Dual-problem-1">Dual problem</a></h2><p>The dual problem of the optimisation problem above is given by:</p><div>\[\begin{alignat*}{2}
&amp;\text{maximize}   &amp; \quad   &amp; -\textstyle{\frac{1}{2}}x^\top Px - b^\top  y - \text{sup}_{s \in \mathcal{K}}(-y^\top s ) \\
&amp;\text{subject to} &amp; &amp; Px + A^\top  y = -q\\
&amp;            &amp; &amp; y \in (\mathcal{K}^\infty)^* ,
\end{alignat*}\]</div><p>with dual variable <span>$y \in \mathbb{R}^m$</span>.</p><h2><a class="nav-anchor" id="Algorithm-1" href="#Algorithm-1">Algorithm</a></h2><p>The algorithm considers a slightly transformed problem. By introducing two dummy variables <span>$\tilde{x} = x$</span> and <span>$\tilde{s} = s$</span> we can rewrite the original problem:</p><div>\[\begin{alignat*}{2}
&amp;\text{minimize}   &amp;  ~   &amp; \textstyle{\frac{1}{2}}\tilde{x}^\top P \tilde{x} + q^\top \tilde{x} + \mathcal{I}_{Ax+s=b}(\tilde{x},\tilde{s}) + \mathcal{I}_{\mathcal{K}}(s)\\
&amp;\text{subject to} &amp; &amp; (\tilde{x},\tilde{s}) = (x,s),
\end{alignat*}\]</div><p>where indicator functions <span>$\mathcal{I}$</span> were used to move the constraints into the objective function. The resulting problem is now in the right format to apply the alternating direction method of multipliers (ADMM). To apply ADMM we first find the augmented Lagrangian <span>$L$</span>:</p><div>\[  L(x,s,\tilde{x},\tilde{s},\lambda,y) = \textstyle{\frac{1}{2}}\tilde{x}^\top P\tilde{x} + q^\top \tilde{x} + \mathcal{I}_{Ax+s=b}(\tilde{x},\tilde{s}) + \mathcal{I}_{\mathcal{K}}(s) + \frac{\sigma}{2} \|\tilde{x} - x + \textstyle{\frac{1}{\sigma}} λ \|_2^2 + \frac{\rho}{2} \| \tilde{s} - s + \textstyle{\frac{1}{\rho}} y \|_2^2.\]</div><p>Minimizing the Lagrangian in an alternating fashion with respect to the two variable pairs <span>$(\tilde{x},\tilde{s})$</span> and <span>$(x,s)$</span> yields the following algorithm steps:</p><div>\[\begin{align*}
    ( \tilde{x}^{k+1},\tilde{s}^{k+1})  &amp;\rightarrow \underset{\tilde{x},\tilde{s}}{\text{argmin }}  L\left( \tilde{x},\tilde{s},x^k,s^k,y^k \right)\\
    x^{k+1} &amp;\leftarrow \tilde{x}^{k+1}  \label{eq:ADMM1}\\
    s^{k+1} &amp;\leftarrow \underset{s}{\text{argmin }}\frac{\rho}{2} \|  \tilde{s}^{k+1}  - s+\textstyle{\frac{1}{\rho}}y^k \|_2^2 + I_{\mathcal{K}}(s), \\
    y^{k+1} &amp;\leftarrow y^k + \rho \left( \tilde{s}^{k+1} -s^{k+1} \right).
\end{align*}\]</div><p>By the construction of the ADMM method those iterates are converging to the global solution. These steps are executed in a loop until convergence. Two important parameters are the ADMM steps sizes <span>$\rho$</span> (<code>Settings.rho</code>) and <span>$\sigma$</span> (<code>Settings.sigma</code>) which can be adjusted via the solver settings.</p><p>The two most important steps of the algorithm happen in the first and third line. The evaluation of the first line turns out to be an equality constrained quadratic program. We get a solution for <span>$( \tilde{x}^{k+1},\tilde{s}^{k+1})$</span> at every iteration by solving the following linear system:</p><div>\[\begin{align*}
\begin{bmatrix}
P + \sigma I &amp; A^\top \\A &amp;- \frac{1}{\rho}I
    \end{bmatrix}\begin{bmatrix}\tilde{x}^{k+1} \\ \nu^{k+1}\end{bmatrix}&amp;= \begin{bmatrix}-q+\sigma x^k \\b-s^k+\frac{1}{\rho}y^k\end{bmatrix}\\
\tilde{s}^{k+1} &amp;= s^k - \frac{1}{\rho}\left(\nu^{k+1} + y^{k}\right).
\end{align*}\]</div><p>Fortunately, the left hand matrix doesn&#39;t change, which is why COSMO only has to factor the matrix once at the start of the algorithm.</p><p>The second important step in the algorithm is the update equation for <span>$s^{k+1}$</span> which can be interpreted as a projection onto the constraint set <span>$\mathcal{K}$</span>:</p><div>\[s^{k+1} = \Pi_{\mathcal{K}}\left( \tilde{s}^{k+1} + \frac{1}{\rho}y^k\right).\]</div><p>The computational cost of this projection is highly dependent on the constraints of the problem. While projections onto the zero set or the nonnegative orthant are inexpensive, projections onto the positive semidefinite cone of order <span>$N$</span> involve an eigen-decomposition. Since methods for eigen-decompositions have a complexity of <span>$\mathcal{O}(N^3)$</span> the projection can become the computationally most expensive operation of the algorithm.</p><h2><a class="nav-anchor" id="Scaling-1" href="#Scaling-1">Scaling</a></h2><p>The convergence of ADMM-based algorithms depends on the relative scaling of the problem data. Especially to improve the convergence of badly scaled problems, COSMO tries to rescale the data in a preprocessing step.</p><p>We rescale the equality constraints with diagonal positive semidefinite matrices <span>$D$</span> and <span>$E$</span>. The scaled problem is given by:</p><div>\[\begin{alignat*}{2}
\label{eq:scaled}
&amp;\text{minimize}   &amp; \quad   &amp; \textstyle{\frac{1}{2}} \hat{x}^\top \hat{P} \hat{x} + \hat{q}^\top \hat{x}\\
&amp;\text{subject to} &amp; &amp; \hat{A} \hat{x} + \hat{s}  = \hat{b},  \\
&amp;            &amp; &amp; \hat{s} \in E\mathcal{K},
\end{alignat*}\]</div><p>with scaled problem data</p><div>\[  \hat{P}=DPD, \quad \hat{q}=Dq,  \quad\hat{A}=EAD, \quad \hat{b}=Eb,\]</div><p>and the scaled convex cone <span>$E\mathcal{K} = \{Ev \in \mathbb{R}^m \mid v \in \mathcal{K} \}$</span>. After solving the scaled problem the original solution is obtained by reversing the scaling:</p><div>\[   x = D\hat{x}, \quad s = E^{-1}\hat{s}, \quad y = E\hat{y}.\]</div><p>To obtain the scaling matrices <span>$D$</span> and <span>$E$</span> we use a modified Ruiz equilibration algorithm which involves a certain number of scaling iterations to equilibrate the column norms of the data matrices <span>$P$</span> and <span>$A$</span>. The number of these iterations can be adjusted by the user with <code>scaling</code>. To disable the scaling step set <code>scaling = 0</code>.</p><h2><a class="nav-anchor" id="Termination-criteria-1" href="#Termination-criteria-1">Termination criteria</a></h2><p>The COSMO algorithm can terminate for four reasons:</p><ul><li>The maximum number of allowed iterations has been reached. The user can specify this value in the solver settings with <code>max_iter</code>.</li><li>The solver runtime reaches the time limit specified by the user (<code>time_limit</code>).</li><li>COSMO detects an infeasible problem.</li><li>The iterates fulfil the termination criteria for convergence.</li></ul><p>COSMO uses the primal and dual residuals of the problem to determine if the algorithm has converged. The primal and dual residuals are given by:</p><div>\[\begin{align*}
r_p &amp;= Ax + s -b,\\
r_d &amp;= Px + q + A^\top y.
\end{align*}\]</div><p>The solver terminates when the <span>$\infty$</span>-norms of the residuals lie below a specified tolerance. COSMO uses the sum of an absolute and relative tolerance term:</p><div>\[\begin{align*}
  \|r_p^k \|_\infty &amp;\leq \epsilon_{\mathrm{abs}} + \epsilon_{\mathrm{rel}} \, \text{max} \left\{ \|Ax^k \|_\infty,\|s^k\|_\infty, \|b\|_\infty \right\},\\
   \|r_d^k\|_\infty &amp;\leq \epsilon_{\mathrm{abs}} + \epsilon_{\mathrm{rel}} \, \text{max} \left\{\|Px^k\|_\infty,\|q\|_\infty, \|A^\top y^k\|_\infty \right\}.
\end{align*}\]</div><p>The absolute and relative tolerances <span>$\epsilon_{\mathrm{abs}}$</span>and <span>$\epsilon_{\mathrm{rel}}$</span> can be set by the user by specifying <code>eps_abs</code> and <code>eps_rel</code>. Furthermore, the user can adjust the number of iterations after which the convergence criteria are checked (<code>check_termination</code>).</p><h2><a class="nav-anchor" id="Infeasibility-detection-1" href="#Infeasibility-detection-1">Infeasibility detection</a></h2><p>COSMO uses conditions based on separating hyperplanes to detect infeasible problems. The conditions for COSMO&#39;s problem format have been developed in [1]. Define the convex set <span>$\mathcal{C} = \mathcal{-K} + \{b\}$</span> then we can use the following infeasibility conditions:</p><div>\[\begin{align*}
\mathcal{P} &amp;= \left\{x \in \mathbb{R}^n \mid  Px = 0, \, Ax \in \mathcal{C}^{\infty}, \, \langle  q,x \rangle &lt; 0  \right\} \\
\mathcal{D} &amp;= \left\{y \in \mathbb{R}^m \mid  A^\top  y  = 0,  \, \sigma_\mathcal{C}(y) &lt; 0 \right\}.
\end{align*}\]</div><p>The existence of some <span>$y \in \mathcal{D}$</span> is a certificate that the problem is primal infeasible, while the existence of some <span>$x \in \mathcal{P}$</span> is a certificate for dual infeasibility. COSMO regularly checks above conditions to detect infeasible problems. If the detection is successful, the solver terminates and returns the status codes <code>:Primal_infeasible</code> or <code>:Dual_infeasible</code>. COSMO checks the conditions every <code>check_infeasibility</code> iterations, which can be adjusted by the user.</p><h3><a class="nav-anchor" id="References-1" href="#References-1">References</a></h3><p>[1] Banjac, G. et al. <em>Infeasibility detection in the alternating direction method of multipliers for convex optimization</em>. <a href="http://people.ee.ethz.ch/~gbanjac/pdfs/admm_infeas.pdf">Preprint</a>, 2017.</p><footer><hr/><a class="previous" href="../decomposition/"><span class="direction">Previous</span><span class="title">Chordal Decomposition</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Examples</span></a></footer></article></body></html>
